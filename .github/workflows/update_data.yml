name: Actualizar Datos Diarios

on:
  schedule:
    # Horario de invierno (CET): 22:00 España = 21:00 UTC
    - cron: "0 21 * * 1-5"
    # Horario de verano (CEST): 22:00 España = 20:00 UTC  
    - cron: "0 20 * * 1-5"
  workflow_dispatch: # Para ejecutar manualmente

jobs:
  update-data:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: ${{ github.ref }}

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          pip install yfinance pandas requests

      - name: Create update script directory
        run: |
          mkdir -p scripts

      - name: Create update script
        run: |
          cat > scripts/update_data.py << 'EOF'
          # scripts/update_data.py
          import yfinance as yf
          import pandas as pd
          import os
          import glob
          import sys
          from datetime import datetime, timedelta
          
          DATA_DIR = "data"
          os.makedirs(DATA_DIR, exist_ok=True)
          
          def get_existing_tickers():
              """Obtiene tickers que ya existen en la carpeta data/"""
              csv_files = glob.glob(os.path.join(DATA_DIR, "*.csv"))
              tickers = []
              for file_path in csv_files:
                  filename = os.path.basename(file_path)
                  if filename.endswith('.csv'):
                      ticker = filename.replace('.csv', '')
                      # Excluir benchmarks para manejarlos por separado
                      if ticker not in ['SPY', 'QQQ']:
                          tickers.append(ticker)
              return tickers
          
          def update_ticker(ticker):
              """Actualiza un ticker específico"""
              try:
                  file_path = os.path.join(DATA_DIR, f"{ticker}.csv")
                  
                  # Si el archivo no existe, descargar datos históricos
                  if not os.path.exists(file_path):
                      print(f"{ticker}: Descargando datos históricos...")
                      data = yf.download(ticker, period="max")
                      if not data.empty:
                          # Asegurar que tenga las columnas necesarias
                          data.to_csv(file_path)
                          print(f"{ticker}: Datos históricos guardados.")
                          return True
                      else:
                          print(f"❌ {ticker}: No se pudieron descargar datos históricos.")
                          return False
                  
                  # Si existe, cargar y actualizar con datos recientes
                  df = pd.read_csv(file_path, index_col="Date", parse_dates=True)
                  
                  # Verificar que el DataFrame no esté vacío
                  if len(df.index) > 0:
                      last_date = df.index[-1]
                      today = datetime.today().date()
                      
                      # Si ya está actualizado (últimos 3 días), salir
                      if last_date.date() >= (today - timedelta(days=3)):
                          print(f"{ticker}: Ya está actualizado hasta {last_date.date()}.")
                          return True
                      
                      # Descargar datos desde la última fecha hasta hoy
                      start_date = last_date - timedelta(days=5)  # Margen de seguridad
                      end_date = today + timedelta(days=1)
                      
                      data = yf.download(ticker, start=start_date, end=end_date)
                      if not data.empty and len(data) > 0:
                          # Asegurar formato
                          data.index = pd.to_datetime(data.index)
                          data = data.rename_axis("Date")
                          
                          # Combinar datos existentes con nuevos
                          df_combined = pd.concat([df, data])
                          # Eliminar duplicados manteniendo el más reciente
                          df_combined = df_combined[~df_combined.index.duplicated(keep='last')]
                          # Ordenar por fecha
                          df_combined = df_combined.sort_index()
                          
                          # Guardar
                          df_combined.to_csv(file_path)
                          print(f"{ticker}: Actualizado hasta {df_combined.index[-1].date()}.")
                          return True
                      else:
                          print(f"⚠️ {ticker}: No hay nuevos datos.")
                          return True
                  else:
                      print(f"{ticker}: Archivo vacío, descargando datos históricos...")
                      data = yf.download(ticker, period="max")
                      if not data.empty:
                          data.to_csv(file_path)
                          print(f"{ticker}: Datos históricos guardados.")
                          return True
                      else:
                          print(f"❌ {ticker}: No se pudieron descargar datos históricos.")
                          return False
                      
              except Exception as e:
                  print(f"❌ Error actualizando {ticker}: {e}")
                  return False
          
          if __name__ == "__main__":
              print("=== Actualización de Datos Diaria ===")
              
              # Obtener tickers existentes en la carpeta data/
              existing_tickers = get_existing_tickers()
              print(f"Encontrados {len(existing_tickers)} tickers para actualizar")
              
              # También agregar benchmarks
              benchmark_tickers = ['SPY', 'QQQ']
              all_tickers = list(set(existing_tickers + benchmark_tickers))
              
              print(f"\nActualizando {len(all_tickers)} tickers en total...")
              
              # Variables para tracking
              successful_updates = 0
              failed_updates = []
              
              # Actualizar cada ticker
              for i, ticker in enumerate(all_tickers, 1):
                  try:
                      print(f"[{i}/{len(all_tickers)}] Actualizando {ticker}...")
                      success = update_ticker(ticker)
                      if success:
                          successful_updates += 1
                      else:
                          failed_updates.append(ticker)
                  except Exception as e:
                      print(f"❌ Error general actualizando {ticker}: {e}")
                      failed_updates.append(ticker)
              
              # Resumen
              print(f"\n=== Resumen de Actualización ===")
              print(f"✅ Exitosos: {successful_updates}")
              print(f"❌ Fallidos: {len(failed_updates)}")
              if failed_updates:
                  print(f"Tickers fallidos: {', '.join(failed_updates)}")
              
              # Guardar resumen en archivo
              summary_file = os.path.join(DATA_DIR, "update_summary.txt")
              with open(summary_file, "w") as f:
                  f.write(f"Actualización {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                  f.write(f"Total tickers: {len(all_tickers)}\n")
                  f.write(f"Exitosos: {successful_updates}\n")
                  f.write(f"Fallidos: {len(failed_updates)}\n")
                  if failed_updates:
                      f.write(f"Tickers fallidos: {', '.join(failed_updates)}\n")
              
              print(f"Resumen guardado en {summary_file}")
              
              # Salir con código de error si hay fallos
              if len(failed_updates) > 0:
                  sys.exit(1)
              else:
                  sys.exit(0)
          EOF

      - name: Run update script
        id: update
        run: |
          python scripts/update_data.py
        continue-on-error: true

      - name: Check for changes
        run: |
          echo "=== Archivos modificados ==="
          git status --porcelain
          echo "=========================="

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Commit and push changes
        run: |
          git add data/*.csv data/update_summary.txt
          if ! git diff --staged --quiet; then
              git commit -m "Actualización automática de datos ($(date +'%Y-%m-%d %H:%M:%S'))"
              git push https://x-access-token:${{ secrets.GITHUB_TOKEN }}@github.com/${{ github.repository }}.git
              echo "✅ Cambios commiteados y subidos"
          else
              echo "ℹ️ No hay cambios para commitear"
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
