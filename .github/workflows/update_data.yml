name: Update CSVs daily

on:
  schedule:
    # Horario de invierno (CET): 22:00 EspaÃ±a = 21:00 UTC
    - cron: "0 21 * * 1-5"
    # Horario de verano (CEST): 22:00 EspaÃ±a = 20:00 UTC  
    - cron: "0 20 * * 1-5"
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install yfinance pandas requests lxml html5lib

      - name: Create update script
        run: |
          cat > update_csv.py << 'EOF'
          import yfinance as yf
          import pandas as pd
          import os
          import glob
          from datetime import datetime, timedelta
          
          def get_existing_tickers():
              """Obtiene solo los tickers que existen en la carpeta data/"""
              csv_files = glob.glob("data/*.csv")
              tickers = []
              for file_path in csv_files:
                  filename = os.path.basename(file_path)
                  if filename.endswith('.csv'):
                      ticker = filename.replace('.csv', '')
                      tickers.append(ticker)
              return sorted(list(set(tickers)))
          
          def update_ticker_data(ticker):
              """Actualiza datos de un ticker especÃ­fico"""
              try:
                  filename = f"data/{ticker}.csv"
                  
                  # Verificar que el archivo existe
                  if not os.path.exists(filename):
                      print(f"âŒ {ticker}: Archivo no encontrado")
                      return False
                  
                  # Leer el archivo existente
                  df = pd.read_csv(filename, index_col="Date", parse_dates=True)
                  
                  # Si el DataFrame no estÃ¡ vacÃ­o
                  if len(df) > 0:
                      last_date = df.index[-1]
                      today = datetime.now()
                      
                      # âœ… CORRECCIÃ“N: Actualizar si no es del dÃ­a de hoy
                      # Considerando que el mercado cierra a las 4PM EST
                      if last_date.date() >= today.date():
                          print(f"âœ… {ticker}: Ya actualizado para hoy {last_date.date()}")
                          return True
                      
                      # âœ… MEJORA: Si es antes de las 4PM EST, verificar si ya tiene datos de ayer
                      from datetime import time
                      import pytz
                      
                      est = pytz.timezone('US/Eastern')
                      now_est = datetime.now(est)
                      market_close = time(16, 0)  # 4:00 PM EST
                      
                      # Si es antes del cierre del mercado y tiene datos de ayer, esperar
                      if now_est.time() < market_close:
                          yesterday = (today - timedelta(days=1)).date()
                          # Si es fin de semana, buscar el Ãºltimo dÃ­a hÃ¡bil
                          while yesterday.weekday() > 4:  # 5=SÃ¡bado, 6=Domingo
                              yesterday = yesterday - timedelta(days=1)
                          
                          if last_date.date() >= yesterday:
                              print(f"â° {ticker}: Mercado aÃºn abierto, datos de {last_date.date()} son los mÃ¡s recientes")
                              return True
                      
                      # Descargar datos desde la Ãºltima fecha
                      print(f"ðŸ“¥ {ticker}: Actualizando desde {last_date.date()}...")
                      start_date = last_date - timedelta(days=7)  # Margen de seguridad
                      end_date = today + timedelta(days=1)
                      
                      new_data = yf.download(ticker, start=start_date, end=end_date, progress=False)
                      if not new_data.empty and len(new_data) > 0:
                          # Asegurar formato de Ã­ndice
                          new_data.index = pd.to_datetime(new_data.index)
                          
                          # Combinar datos eliminando duplicados
                          combined = pd.concat([df, new_data])
                          combined = combined[~combined.index.duplicated(keep='last')].sort_index()
                          
                          # Solo guardar si hay datos nuevos
                          if len(combined) > len(df):
                              combined.to_csv(filename)
                              print(f"âœ… {ticker}: Actualizado hasta {combined.index[-1].date()} (+{len(combined)-len(df)} dÃ­as)")
                              return True
                          else:
                              print(f"â„¹ï¸ {ticker}: Sin datos nuevos")
                              return True
                      else:
                          print(f"âš ï¸ {ticker}: No hay nuevos datos en Yahoo Finance")
                          return True
                  else:
                      # Archivo vacÃ­o, descargar historial completo
                      print(f"ðŸ“¥ {ticker}: Archivo vacÃ­o, descargando historial completo...")
                      data = yf.download(ticker, period="max", progress=False)
                      if not data.empty:
                          data.to_csv(filename)
                          print(f"ðŸ’¾ {ticker}: Historial guardado ({len(data)} dÃ­as)")
                          return True
                      else:
                          print(f"âŒ {ticker}: No se pudo descargar historial")
                          return False
                          
              except Exception as e:
                  print(f"âŒ {ticker}: Error - {str(e)[:100]}")
                  return False
          
          if __name__ == "__main__":
              print("=" * 50)
              print("ðŸš€ ACTUALIZACIÃ“N DIARIA DE DATOS")
              print("=" * 50)
              print(f"ðŸ“… Fecha/Hora: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} UTC")
              
              # Solo actualizar los tickers que existen en la carpeta data/
              tickers = get_existing_tickers()
              print(f"ðŸ“Š Encontrados {len(tickers)} archivos CSV para actualizar")
              
              if len(tickers) > 20:
                  print(f"ðŸ“ Primeros 20: {', '.join(tickers[:20])}...")
              else:
                  print(f"ðŸ“ Tickers: {', '.join(tickers)}")
              
              # Asegurar que SPY y QQQ estÃ©n incluidos si existen
              important_tickers = ['SPY', 'QQQ']
              for important in important_tickers:
                  if important in tickers:
                      print(f"â­ Ticker prioritario encontrado: {important}")
              
              print("\n" + "=" * 50)
              print("INICIANDO ACTUALIZACIÃ“N")
              print("=" * 50 + "\n")
              
              updated = 0
              no_changes = 0
              errors = 0
              
              for i, ticker in enumerate(tickers, 1):
                  print(f"\n[{i}/{len(tickers)}] Procesando {ticker}...")
                  result = update_ticker_data(ticker)
                  if result:
                      if "Sin datos nuevos" in str(result) or "Ya actualizado" in str(result):
                          no_changes += 1
                      else:
                          updated += 1
                  else:
                      errors += 1
                  
                  # PequeÃ±a pausa cada 50 tickers para no sobrecargar
                  if i % 50 == 0:
                      import time
                      time.sleep(1)
              
              print("\n" + "=" * 50)
              print("ðŸ“Š RESUMEN DE ACTUALIZACIÃ“N")
              print("=" * 50)
              print(f"âœ… Actualizados con nuevos datos: {updated}")
              print(f"â„¹ï¸ Sin cambios necesarios: {no_changes}")
              print(f"âŒ Errores: {errors}")
              print(f"ðŸ“Š Total procesados: {len(tickers)}")
              print("=" * 50)
              
              # Verificar algunos archivos para confirmar fechas
              print("\nðŸ” VerificaciÃ³n de Ãºltimas fechas:")
              sample_tickers = ['SPY', 'QQQ', 'AAPL', 'MSFT', 'GOOGL']
              for ticker in sample_tickers:
                  if ticker in tickers:
                      try:
                          df = pd.read_csv(f"data/{ticker}.csv", index_col="Date", parse_dates=True)
                          if len(df) > 0:
                              print(f"  {ticker}: Ãšltimo dato = {df.index[-1].date()}")
                      except:
                          pass
          EOF

      - name: Install pytz for timezone handling
        run: pip install pytz

      - name: Run update script
        run: python update_csv.py

      - name: Commit and push changes
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          
          # Ver quÃ© archivos han cambiado
          git status
          
          # Agregar todos los CSVs modificados
          git add data/*.csv
          
          # Hacer commit solo si hay cambios
          if git diff --staged --quiet; then
            echo "ðŸ“Š No hay cambios para commitear"
          else
            git commit -m "ðŸ“Š Auto-update CSVs - $(date -u +'%Y-%m-%d %H:%M:%S') UTC"
            git push
            echo "âœ… Cambios pusheados exitosamente"
          fi
